% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/thresholdMultiWeighted.r
\name{thresholdMultiWeighted}
\alias{thresholdMultiWeighted}
\title{Weighted thresholds for multi-class predictions}
\usage{
thresholdMultiWeighted(..., thresholds = seq(0, 1, by = 0.01), na.rm = FALSE)
}
\arguments{
\item{...}{A set of two or more objects, each of which can be any of a 1- or 2-column matrix or data frame or a numeric vector. The objects must be listed in \emph{reverse} order of \emph{expected} probability. For example, you might have a set of predictions for objects you expect to have a high predicted probability of occurrence (e.g., presences of an animal), a set that you expect to have middle levels of probability of occurrence (e.g., sites that were recently vacated), and a set for which you expect a low level of predicted probability (e.g., sites that have been long-vacated). In this example you should list the cases in order: present-cases, short-term absence cases, long-term absence cases. If a 2-column matrix or data frame is supplied, then the first column is assumed to represent predictions and the second assumed to represent weights.  If you do not specify weights then every case will be assumed to have the same weight.}

\item{thresholds}{Numeric vector. Thresholds at which to calculate the sum of sensitivity and specificity. The default evaluates all values from 0 to 1 in steps of 0.01.}

\item{na.rm}{Logical. If \code{TRUE} then remove any presences and associated weights and background predictions and associated weights with \code{NA}s.}
}
\value{

}
\description{
This function calculates thresholds for cases where predictions are intended to be indicative of the state of three or more ordered categories. For example, a model might be intended to differentiate between sites where a species is present, sites where the species has been absent for a short time, and sites where the species has been absent for a long time. In this case, two thresholds would be needed to separate presences from short-term absences, and short-term absences from long-term absences. It is possible to simply calculate thresholds for each of these pairwise cases while ignoring the third case. However, this is not guaranteed to achieve any particular thresholding rule across all categories (e.g., maximization of the sum of sensitivity and specificity). Note that it is possible to have multiple combinations of thresholds that do equally well under any given rule for finding the "best" set of thresholds.
}
\examples{
set.seed(123)
par(mfrow=c(1, 3))

thresholds <- seq(0, 1, by=0.05)

### 3 cases of equal size, no weights assigned so all are equal
A <- runif(20, 0.4, 1)
B <- runif(20, 0.3, 0.8)
C <- runif(20, 0, 0.6)

r <- thresholdMultiWeighted(A, B, C, thresholds=thresholds)

# size of circle indicates sum of sensitivity and specificity for each
# combination of thresholds
plot(r$thold_A_over_B, r$thold_B_over_C, cex=r$sumTprTnr,
	xlab='Threshold separating A and B',
	ylab='Threshold separating B and C',
	main='Equal cases, equal weighting',
	xlim=c(0, 1), ylim=c(0, 1)
)

# pluses indicate which combination of thresholds maximize the
# sum of sensitivities and specificities
maxs <- which(r$maxSumTprTnr)
points(r$thold_A_over_B[maxs], r$thold_B_over_C[maxs], pch=3)

# down-triangles indicate which combination of thresholds minimize
# differences mean differences between sensitivities and specificities
# and their mean
maxs <- which(r$minDiffTprTnr)
points(r$thold_A_over_B[maxs], r$thold_B_over_C[maxs], pch=6)

# up-triangles indicate which combination of thresholds minimize
# differences sum of squared differences between sensitivities and
# specificities and their mean
# (in this example, they are the the same as previous thresholds)
maxs <- which(r$minSqDiffTprTnr)
points(r$thold_A_over_B[maxs], r$thold_B_over_C[maxs], pch=2)


### 3 cases of unequal size, no weights assigned so all are equal
A <- runif(20, 0.4, 1)
B <- runif(200, 0.3, 0.8)
C <- runif(20, 0, 0.6)

r <- thresholdMultiWeighted(A, B, C, thresholds=thresholds)

# size of circle indicates sum of sensitivity and specificity for each
# combination of thresholds
plot(r$thold_A_over_B, r$thold_B_over_C, cex=r$sumTprTnr,
	xlab='Threshold separating A and B',
	ylab='Threshold separating B and C',
	main='Case B most numerous',
	xlim=c(0, 1), ylim=c(0, 1)
)

# pluses indicate which combination of thresholds maximize the
# sum of sensitivities and specificities
maxs <- which(r$maxSumTprTnr)
points(r$thold_A_over_B[maxs], r$thold_B_over_C[maxs], pch=3)

# down-triangles indicate which combination of thresholds minimize
# differences mean differences between sensitivities and specificities
# and their mean
maxs <- which(r$minDiffTprTnr)
points(r$thold_A_over_B[maxs], r$thold_B_over_C[maxs], pch=6)

# up-triangles indicate which combination of thresholds minimize
# differences sum of squared differences between sensitivities and
# specificities and their mean
# (in this example, they are the the same as previous thresholds)
maxs <- which(r$minSqDiffTprTnr)
points(r$thold_A_over_B[maxs], r$thold_B_over_C[maxs], pch=2)

### 3 cases of equal size, weights assigned so getting case A right
### is "worth" more
A <- runif(20, 0.4, 1)
B <- runif(20, 0.3, 0.8)
C <- runif(20, 0, 0.6)

A <- cbind(A, rep(1, 20))
B <- cbind(B, rep(0.5, 20))
C <- cbind(C, rep(0.1, 20))

r <- thresholdMultiWeighted(A, B, C, thresholds=thresholds)

# size of circle indicates sum of sensitivity and specificity for each
# combination of thresholds
plot(r$thold_A_over_B, r$thold_B_over_C, cex=r$sumTprTnr,
	xlab='Threshold separating A and B',
	ylab='Threshold separating B and C',
	main='Weight of case A weight > case B > case C',
	xlim=c(0, 1), ylim=c(0, 1)
)

# pluses indicate which combination of thresholds maximize the
# sum of sensitivities and specificities
maxs <- which(r$maxSumTprTnr)
points(r$thold_A_over_B[maxs], r$thold_B_over_C[maxs], pch=3)

# down-triangles indicate which combination of thresholds minimize
# differences mean differences between sensitivities and specificities
# and their mean
maxs <- which(r$minDiffTprTnr)
points(r$thold_A_over_B[maxs], r$thold_B_over_C[maxs], pch=6)

# up-triangles indicate which combination of thresholds minimize
# differences sum of squared differences between sensitivities and
# specificities and their mean
# (in this example, they are the the same as previous thresholds)
maxs <- which(r$minSqDiffTprTnr)
points(r$thold_A_over_B[maxs], r$thold_B_over_C[maxs], pch=2)

}
\seealso{
\code{\link{thresholdWeighted}}, \code{\link[dismo]{threshold}}, \code{\link[dismo]{evaluate}}
}
